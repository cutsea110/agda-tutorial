<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ambrus Kaposi, Péter Diviánszky" />
  <title>Motivation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="Agda.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Motivation</h1>
<h2 class="author">Ambrus Kaposi, Péter Diviánszky</h2>
<h3 class="date">2012. 02. 13., 2013. 01.</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#about-the-tutorial">About the tutorial</a></li>
<li><a href="#what-is-agda-good-for">What is Agda good for?</a></li>
<li><a href="#benefits-of-programming-in-agda">Benefits of programming in Agda</a></li>
<li><a href="#benefits-of-creating-formal-systems-in-agda">Benefits of creating formal systems in Agda</a></li>
<li><a href="#benefits-of-completing-the-tutorial">Benefits of completing the tutorial</a></li>
</ul>
</div>
<h1 id="about-the-tutorial"><a href="#about-the-tutorial">About the tutorial</a></h1>
<p>Goals</p>
<ul>
<li>show what is Agda good for</li>
<li>teach Agda syntax and semantics</li>
<li>teach Agda programming skills</li>
</ul>
<p>Features</p>
<ul>
<li>slides: 1/3 examples, 1/3 explanation, 1/3 exercises</li>
<li>only (part of) secondary school mathematics is required</li>
</ul>
<p><a href="About.html"><em>More about the tutorial</em></a></p>
<h1 id="what-is-agda-good-for"><a href="#what-is-agda-good-for">What is Agda good for?</a></h1>
<p><strong>To utilize the capacity of computers in a reliable way.</strong></p>
<p>Target:</p>
<p>programming and mathematics;<br />formal definitions, theorems, proofs and algorithms</p>
<h1 id="benefits-of-programming-in-agda"><a href="#benefits-of-programming-in-agda">Benefits of programming in Agda</a></h1>
<ul>
<li><strong>eliminating errors</strong>
<ul>
<li>no runtime errors<br /> Inevitable errors like I/O errors are handled, others are excluded by design.</li>
<li>no non-productive infinite loops</li>
</ul></li>
<li><strong>machine checked documentation</strong><br /> Any functional properties can be formalized and proved; proof checking is automatic.
<ul>
<li>distinction between finite and infinite data like lists vs. streams</li>
<li>invariant properties of data like sorted list, balanced tree can be maintained</li>
<li>function properties like commutativity, associativity can be maintained</li>
</ul></li>
<li><strong>exact interfaces</strong><br /> Formal specification can be given with the help of exact mathematical concepts like groups, rings, lattices, categories, ...</li>
<li><strong>safe optimization</strong>
<ul>
<li>runtime checks like array index bounds checks are eliminated</li>
<li>defensive coding (generous on input, strict on output) is unnecessary -- no overhead of it</li>
<li>safe optimization on special input like associative input function of a higher order function</li>
</ul></li>
<li><strong>high level programming</strong>
<ul>
<li>programming with types as data (generic programming, universes)<br /> Type may depend on runtime value and still checked in compile time.</li>
<li>reflection</li>
<li>Previously unseen range of embedded domain specific languages can be defined with arbitrary precision.</li>
</ul></li>
</ul>
<h1 id="benefits-of-creating-formal-systems-in-agda"><a href="#benefits-of-creating-formal-systems-in-agda">Benefits of creating formal systems in Agda</a></h1>
<p>Definitions</p>
<ul>
<li>classical, constructive and modal logical connectives are definable</li>
</ul>
<p>Theorems</p>
<ul>
<li>one can quantify over elements, properties, properties of properties etc.<br /> (Agda has the strength of an infinite-order logic)</li>
</ul>
<p>Proofs</p>
<ul>
<li>Automatic simplification of expressions gives the automatic part of proofs.<br /> In this way algorithms can be used during proofs.</li>
<li>automatic proof checking</li>
</ul>
<p>Additional features</p>
<ul>
<li>inferred terms, implicit arguments</li>
<li>holes, interactive development</li>
<li>unicode characters, mixfix operators</li>
</ul>
<!-- comment
| Eliminating errors from programming
| ===================================
| 
| Method               Example
| -------------------  ----------------------------------------
| run-time monitoring  `Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException`
| testing              `quickCheck ((\s → s == s) : List Char → Bool)`
| model checking       NuSMV
|                      `state : {ready, busy}, request : boolean`
|                      `init(state) := ready`
|                      `next(state) := if state = ready & request = TRUE`
|                      `then busy else {ready, busy}`
| type systems         `4 : Int`
|                      `[1,2,4] : List Int`
|                      `(+) 4 : Int → Int`
|                      `(+) : Num a ⇒ a → a → a`
| formal verification* Fóthi, Horváth et al.
|                      B method, Hoare-logic, Coq
| 
| -------------------------
| 
| *give examples
| 
| Remark: we use `:` as the type-of predicate and `∷` as the list constructor
| 
| 
| Type systems
| ============
| 
| Problem:
| 
|     +─────────────────────────+
|     |all programs             |
|     |        +─────────────+  |
|     |        |well-typed  ?|  |
|     |        |programs   ? |  |
|     |     +──+──────────+  |  |
|     |     |  |XXXXXXXXXX|  |  |
|     |     |  |XXXXXXXXXX|  |  |
|     |     |  ───────────+──+  |
|     |     |good programs|     |
|     |     +─────────────+     |
|     +─────────────────────────+
| 
| Solution: more expressive and fine-grained type systems
| 
| 
| Examples of Haskell type system limits
| ======================================
| 
| [`Data.Word`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Word.html)
| 
| [`HaskellDB`](http://hackage.haskell.org/packages/archive/haskelldb/2.1.1/doc/html/Database-HaskellDB-BoundedList.html#t:N255)
| 
| [Square matrices](http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps)
| 
| More: types of fixed-length lists, sorted lists, balanced trees, numbers that are between 13 and 45 etc.
| 
| Fixing Haskell 98: [MultiParamTypeClasses](http://hackage.haskell.org/trac/haskell-prime/wiki/MultiParamTypeClasses), [GADTs](http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs), [FunctionalDependencies](http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies), [RankNTypes](http://hackage.haskell.org/trac/haskell-prime/wiki/RankNTypes), [KindAnnotations](http://hackage.haskell.org/trac/haskell-prime/wiki/KindAnnotations) etc.
| 
| 
| What is Agda?
| =============
| 
| Agda is a programming language with a type system so expressive that makes it a formal verification tool.
| 
-->


<h1 id="benefits-of-completing-the-tutorial"><a href="#benefits-of-completing-the-tutorial">Benefits of completing the tutorial</a></h1>
<ul>
<li>use Agda directly (you have to put more effort in learning Agda for this)
<ul>
<li>develop formal systems, use Agda during research</li>
<li>write high-assurance code<br /> Note that the current compiler is not industrial-strength, libraries are missing,<br /> solutions for individual problems are not worked out.</li>
</ul></li>
<li>learn similar languages easier
<ul>
<li>most Haskell type system extensions are just special cases
<ul>
<li>Haskell is a practical general-purpose programming language also used in industry.</li>
</ul></li>
<li>languages with similar goals: Coq, Idris, Epigram
<ul>
<li>write formal proofs in Coq which is more mainstream</li>
</ul></li>
</ul></li>
<li>use the ideas presented here
<ul>
<li>have a better programming style / understanding in other languages</li>
<li>steal the ideas</li>
</ul></li>
<li>learn theory easier (will be more familiar for you)
<ul>
<li>type theory
<ul>
<li>dependent types</li>
</ul></li>
<li>constructive mathematics</li>
<li>semantics of programming languages
<ul>
<li>λ-calculus</li>
</ul></li>
</ul></li>
</ul>
</body>
</html>
